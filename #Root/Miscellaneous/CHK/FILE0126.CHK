/*!
 * Font Awesome Free 5.14.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['fontawesome-free-conflict-detection'] = {})));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  var _WINDOW = {};
  var _DOCUMENT = {};

  try {
    if (typeof window !== 'undefined') _WINDOW = window;
    if (typeof document !== 'undefined') _DOCUMENT = document;
  } catch (e) {}

  var _ref = _WINDOW.navigator || {},
      _ref$userAgent = _ref.userAgent,
      userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent;

  var WINDOW = _WINDOW;
  var DOCUMENT = _DOCUMENT;
  var IS_BROWSER = !!WINDOW.document;
  var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === 'function' && typeof DOCUMENT.createElement === 'function';
  var IS_IE = ~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/');

  var functions = [];

  var listener = function listener() {
    DOCUMENT.removeEventListener('DOMContentLoaded', listener);
    loaded = 1;
    functions.map(function (fn) {
      return fn();
    });
  };

  var loaded = false;

  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded) DOCUMENT.addEventListener('DOMContentLoaded', listener);
  }

  function domready (fn) {
    if (!IS_DOM) return;
    loaded ? setTimeout(fn, 0) : functions.push(fn);
  }

  function report (_ref) {
    var nodesTested = _ref.nodesTested,
        nodesFound = _ref.nodesFound;
    var timedOutTests = {};

    for (var key in nodesFound) {
      if (!(nodesTested.conflict[key] || nodesTested.noConflict[key])) {
        timedOutTests[key] = nodesFound[key];
      }
    }

    var conflictsCount = Object.keys(nodesTested.conflict).length;

    if (conflictsCount > 0) {
      console.info("%cConflict".concat(conflictsCount > 1 ? 's' : '', " found:"), 'color: darkred; font-size: large');
      var data = {};

      for (var _key in nodesTested.conflict) {
        var item = nodesTested.conflict[_key];
        data[_key] = {
          'tagName': item.tagName,
          'src/href': item.src || item.href || 'n/a',
          'innerText excerpt': item.innerText && item.innerText !== '' ? item.innerText.slice(0, 200) + '...' : '(empty)'
        };
      }

      console.table(data);
    }

    var noConflictsCount = Object.keys(nodesTested.noConflict).length;

    if (noConflictsCount > 0) {
      console.info("%cNo conflict".concat(noConflictsCount > 1 ? 's' : '', " found with ").concat(noConflictsCount == 1 ? 'this' : 'these', ":"), 'color: green; font-size: large');
      var _data = {};

      for (var _key2 in nodesTested.noConflict) {
        var _item = nodesTested.noConflict[_key2];
        _data[_key2] = {
          'tagName': _item.tagName,
          'src/href': _item.src || _item.href || 'n/a',
          'innerText excerpt': _item.innerText && _item.innerText !== '' ? _item.innerText.slice(0, 200) + '...' : '(empty)'
        };
      }

      console.table(_data);
    }

    var timeOutCount = Object.keys(timedOutTests).length;

    if (timeOutCount > 0) {
      console.info("%cLeftovers--we timed out before collecting test results for ".concat(timeOutCount == 1 ? 'this' : 'these', ":"), 'color: blue; font-size: large');
      var _data2 = {};

      for (var _key3 in timedOutTests) {
        var _item2 = timedOutTests[_key3];
        _data2[_key3] = {
          'tagName': _item2.tagName,
          'src/href': _item2.src || _item2.href || 'n/a',
          'innerText excerpt': _item2.innerText && _item2.innerText !== '' ? _item2.innerText.slice(0, 200) + '...' : '(empty)'
        };
      }

      console.table(_data2);
    }
  }

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var md5 = createCommonjsModule(function (module) {

    (function ($) {
      /**
       * Add integers, wrapping at 2^32.
       * This uses 16-bit operations internally to work around bugs in interpreters.
       *
       * @param {number} x First integer
       * @param {number} y Second integer
       * @returns {number} Sum
       */

      function safeAdd(x, y) {
        var lsw = (x & 0xffff) + (y & 0xffff);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 0xffff;
      }
      /**
       * Bitwise rotate a 32-bit number to the left.
       *
       * @param {number} num 32-bit number
       * @param {number} cnt Rotation count
       * @returns {number} Rotated number
       */


      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} q q
       * @param {number} a a
       * @param {number} b b
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */


      function md5cmn(q, a, b, x, s, t) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */


      function md5ff(a, b, c, d, x, s, t) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */


      function md5gg(a, b, c, d, x, s, t) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */


      function md5hh(a, b, c, d, x, s, t) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t);
      }
      /**
       * Basic operation the algorithm uses.
       *
       * @param {number} a a
       * @param {number} b b
       * @param {number} c c
       * @param {number} d d
       * @param {number} x x
       * @param {number} s s
       * @param {number} t t
       * @returns {number} Result
       */


      function md5ii(a, b, c, d, x, s, t) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t);
      }
      /**
       * Calculate the MD5 of an array of little-endian words, and a bit length.
       *
       * @param {Array} x Array of little-endian words
       * @param {number} len Bit length
       * @returns {Array<number>} MD5 Array
       */


      function binlMD5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i;
        var olda;
        var oldb;
        var oldc;
        var oldd;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;

        for (i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5ff(a, b, c, d, x[i], 7, -680876936);
          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5gg(b, c, d, a, x[i], 20, -373897302);
          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5hh(d, a, b, c, x[i], 11, -358537222);
          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5ii(a, b, c, d, x[i], 6, -198630844);
          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safeAdd(a, olda);
          b = safeAdd(b, oldb);
          c = safeAdd(c, oldc);
          d = safeAdd(d, oldd);
        }

        return [a, b, c, d];
      }
      /**
       * Convert an array of little-endian words to a string
       *
       * @param {Array<number>} input MD5 Array
       * @returns {string} MD5 string
       */


      function binl2rstr(input) {
        var i;
        var output = '';
        var length32 = input.length * 32;

        for (i = 0; i < length32; i += 8) {
          output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);
        }

        return output;
      }
      /**
       * Convert a raw string to an array of little-endian words
       * Characters >255 have their high-byte silently ignored.
       *
       * @param {string} input Raw input string
       * @returns {Array<number>} Array of little-endian words
       */


      function rstr2binl(input) {
        var i;
        var output = [];
        output[(input.length >> 2) - 1] = undefined;

        for (i = 0; i < output.length; i += 1) {
          output[i] = 0;
        }

        var length8 = input.length * 8;

        for (i = 0; i < length8; i += 8) {
          output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
        }

        return output;
      }
      /**
       * Calculate the MD5 of a raw string
       *
       * @param {string} s Input string
       * @returns {string} Raw MD5 string
       */


      function rstrMD5(s) {
        return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
      }
      /**
       * Calculates the HMAC-MD5 of a key and some data (raw strings)
       *
       * @param {string} key HMAC key
       * @param {string} data Raw input string
       * @returns {string} Raw MD5 string
       */


      function rstrHMACMD5(key, data) {
        var i;
        var bkey = rstr2binl(key);
        var ipad = [];
        var opad = [];
        var hash;
        ipad[15] = opad[15] = undefined;

        if (bkey.length > 16) {
          bkey = binlMD5(bkey, key.length * 8);
        }

        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5c5c5c5c;
        }

        hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
      }
      /**
       * Convert a raw string to a hex string
       *
       * @param {string} input Raw input string
       * @returns {string} Hex encoded string
       */


      function rstr2hex(input) {
        var hexTab = '0123456789abcdef';
        var output = '';
        var x;
        var i;

        for (i = 0; i < input.length; i += 1) {
          x = input.charCodeAt(i);
          output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);
        }

        return output;
      }
      /**
       * Encode a string as UTF-8
       *
       * @param {string} input Input string
       * @returns {string} UTF8 string
       */


      function str2rstrUTF8(input) {
        return unescape(encodeURIComponent(input));
      }
      /**
       * Encodes input string as raw MD5 string
       *
       * @param {string} s Input string
       * @returns {string} Raw MD5 string
       */


      function rawMD5(s) {
        return rstrMD5(str2rstrUTF8(s));
      }
      /**
       * Encodes input string as Hex encoded string
       *
       * @param {string} s Input string
       * @returns {string} Hex encoded string
       */


      function hexMD5(s) {
        return rstr2hex(rawMD5(s));
      }
      /**
       * Calculates the raw HMAC-MD5 for the given key and data
       *
       * @param {string} k HMAC key
       * @param {string} d Input string
       * @returns {string} Raw MD5 string
       */


      function rawHMACMD5(k, d) {
        return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
      }
      /**
       * Calculates the Hex encoded HMAC-MD5 for the given key and data
       *
       * @param {string} k HMAC key
       * @param {string} d Input string
       * @returns {string} Raw MD5 string
       */


      function hexHMACMD5(k, d) {
        return rstr2hex(rawHMACMD5(k, d));
      }
      /**
       * Calculates MD5 value for a given string.
       * If a key is provided, calculates the HMAC-MD5 value.
       * Returns a Hex encoded string unless the raw argument is given.
       *
       * @param {string} string Input string
       * @param {string} [key] HMAC key
       * @param {boolean} raw Raw oytput switch
       * @returns {string} MD5 output
       */


      function md5(string, key, raw) {
        if (!key) {
          if (!raw) {
            return hexMD5(string);
          }

          return rawMD5(string);
        }

        if (!raw) {
          return hexHMACMD5(key, string);
        }

        return rawHMACMD5(key, string);
      }

      if (module.exports) {
        module.exports = md5;
      } else {
        $.md5 = md5;
      }
    })(commonjsGlobal);
  });

  function md5ForNode(node) {
    if (null === node || 'object' !== _typeof(node)) return undefined;

    if (node.src) {
      return md5(node.src);
    } else if (node.href) {
      return md5(node.href);
    } else if (node.innerText && '' !== node.innerText) {
      // eslint-disable-line yoda
      return md5(node.innerText);
    } else {
      return undefined;
    }
  }

  var diagScriptId = 'fa-kits-diag';
  var nodeUnderTestId = 'fa-kits-node-under-test';
  var md5Attr = 'data-md5';
  var detectionIgnoreAttr = 'data-fa-detection-ignore';
  var timeoutAttr = 'data-fa-detection-timeout';
  var resultsCollectionMaxWaitAttr = 'data-fa-detection-results-collection-max-wait';

  var silenceErrors = function silenceErrors(e) {
    e.preventDefault();
    e.stopPropagation();
  };

  function pollUntil(_ref) {
    var _ref$fn = _ref.fn,
        fn = _ref$fn === void 0 ? function () {
      return true;
    } : _ref$fn,
        _ref$initialDuration = _ref.initialDuration,
        initialDuration = _ref$initialDuration === void 0 ? 1 : _ref$initialDuration,
        _ref$maxDuration = _ref.maxDuration,
        maxDuration = _ref$maxDuration === void 0 ? WINDOW.FontAwesomeDetection.timeout : _ref$maxDuration,
        _ref$showProgress = _ref.showProgress,
        showProgress = _ref$showProgress === void 0 ? false : _ref$showProgress,
        progressIndicator = _ref.progressIndicator;
    return new Promise(function (resolve, reject) {
      // eslint-disable-line compat/compat
      function poll(duration, cumulativeDuration) {
        setTimeout(function () {
          var result = fn();

          if (showProgress) {
            console.info(progressIndicator);
          }

          if (!!result) {
            // eslint-disable-line no-extra-boolean-cast
            resolve(result);
          } else {
            var nextDuration = 250;
            var nextCumulativeDuration = nextDuration + cumulativeDuration;

            if (nextCumulativeDuration <= maxDuration) {
              poll(nextDuration, nextCumulativeDuration);
            } else {
              reject('timeout'); // eslint-disable-line prefer-promise-reject-errors
            }
          }
        }, duration);
      }

      poll(initialDuration, 0);
    });
  }

  function detectWebfontConflicts() {
    var linkTags = Array.from(DOCUMENT.getElementsByTagName('link')).filter(function (t) {
      return !t.hasAttribute(detectionIgnoreAttr);
    });
    var styleTags = Array.from(DOCUMENT.getElementsByTagName('style')).filter(function (t) {
      if (t.hasAttribute(detectionIgnoreAttr)) {
        return false;
      } // If the browser has loaded the FA5 CSS, let's not test that <style> element.
      // Its enough that we'll be testing for traces of the corresponding JS being loaded, and testing
      // this <style> would only produce a false negative anyway.


      if (WINDOW.FontAwesomeConfig && t.innerText.match(new RegExp("svg:not\\(:root\\)\\.".concat(WINDOW.FontAwesomeConfig.replacementClass)))) {
        return false;
      }

      return true;
    });

    function runDiag(scriptOrLinkTag, md5) {
      var diagFrame = DOCUMENT.createElement('iframe'); // Using "visibility: hidden; position: absolute" instead of "display: none;" because
      // Firefox will not return the expected results for getComputedStyle if our iframe has display: none.

      diagFrame.setAttribute('style', 'visibility: hidden; position: absolute; height: 0; width: 0;');
      var testIconId = 'fa-test-icon-' + md5;
      var iTag = DOCUMENT.createElement('i');
      iTag.setAttribute('class', 'fa fa-coffee');
      iTag.setAttribute('id', testIconId);
      var diagScript = DOCUMENT.createElement('script');
      diagScript.setAttribute('id', diagScriptId); // WARNING: this function will be toString()'d and assigned to innerText of the diag script
      // element that we'll be putting into a diagnostic iframe.
      // That means that this code won't compile until after the outer script has run and injected
      // this code into the iframe. There are some compile time errors that might occur there.
      // For example, using single line (double-slash) comments like this one inside that function
      // will probably cause it to choke. Chrome will show an error like this:
      // Uncaught SyntaxError: Unexpected end of input

      var diagScriptFun = function diagScriptFun(nodeUnderTestId, testIconId, md5, parentOrigin) {
        parent.FontAwesomeDetection.__pollUntil({
          fn: function fn() {
            var iEl = document.getElementById(testIconId);
            var computedStyle = window.getComputedStyle(iEl);
            var fontFamily = computedStyle.getPropertyValue('font-family');

            if (!!fontFamily.match(/FontAwesome/) || !!fontFamily.match(/Font Awesome 5/)) {
              return true;
            } else {
              return false;
            }
          }
        }).then(function () {
          var node = document.getElementById(nodeUnderTestId);
          parent.postMessage({
            type: 'fontawesome-conflict',
            technology: 'webfont',
            href: node.href,
            innerText: node.innerText,
            tagName: node.tagName,
            md5: md5
          }, parentOrigin);
        }).catch(function (e) {
          var node = document.getElementById(nodeUnderTestId);

          if (e === 'timeout') {
            parent.postMessage({
              type: 'no-conflict',
              technology: 'webfont',
              href: node.src,
              innerText: node.innerText,
              tagName: node.tagName,
              md5: md5
            }, parentOrigin);
          } else {
            console.error(e);
          }
        });
      };

      var parentOrigin = WINDOW.location.origin === 'file://' ? '*' : WINDOW.location.origin;
      diagScript.innerText = "(".concat(diagScriptFun.toString(), ")('").concat(nodeUnderTestId, "', '").concat(testIconId || 'foo', "', '").concat(md5, "', '").concat(parentOrigin, "');");

      diagFrame.onload = function () {
        diagFrame.contentWindow.addEventListener('error', silenceErrors, true);
        diagFrame.contentDocument.head.appendChild(diagScript);
        diagFrame.contentDocument.head.appendChild(scriptOrLinkTag);
        diagFrame.contentDocument.body.appendChild(iTag);
      };

      domready(function () {
        return DOCUMENT.body.appendChild(diagFrame);
      });
    }

    var cssByMD5 = {};

    for (var i = 0; i < linkTags.length; i++) {
      var linkUnderTest = DOCUMENT.createElement('link');
      linkUnderTest.setAttribute('id', nodeUnderTestId);
      linkUnderTest.setAttribute('href', linkTags[i].href);
      linkUnderTest.setAttribute('rel', linkTags[i].rel);
      var md5ForLink = md5ForNode(linkTags[i]);
      linkUnderTest.setAttribute(md5Attr, md5ForLink);
      cssByMD5[md5ForLink] = linkTags[i];
      runDiag(linkUnderTest, md5ForLink);
    }

    for (var _i = 0; _i < styleTags.length; _i++) {
      var styleUnderTest = DOCUMENT.createElement('style');
      styleUnderTest.setAttribute('id', nodeUnderTestId);
      var md5ForStyle = md5ForNode(styleTags[_i]);
      styleUnderTest.setAttribute(md5Attr, md5ForStyle);
      styleUnderTest.innerText = styleTags[_i].innerText;
      cssByMD5[md5ForStyle] = styleTags[_i];
      runDiag(styleUnderTest, md5ForStyle);
    }

    return cssByMD5;
  }

  function detectSvgConflicts(currentScript) {
    var scripts = Array.from(DOCUMENT.scripts).filter(function (t) {
      return !t.hasAttribute(detectionIgnoreAttr) && t !== currentScript;
    });
    var scriptsByMD5 = {};

    var _loop = function _loop(scriptIdx) {
      var diagFrame = DOCUMENT.createElement('iframe');
      diagFrame.setAttribute('style', 'display:none;');
      var scriptUnderTest = DOCUMENT.createElement('script');
      scriptUnderTest.setAttribute('id', nodeUnderTestId);
      var md5ForScript = md5ForNode(scripts[scriptIdx]);
      scriptUnderTest.setAttribute(md5Attr, md5ForScript);
      scriptsByMD5[md5ForScript] = scripts[scriptIdx];

      if (scripts[scriptIdx].src !== '') {
        scriptUnderTest.src = scripts[scriptIdx].src;
      }

      if (scripts[scriptIdx].innerText !== '') {
        scriptUnderTest.innerText = scripts[scriptIdx].innerText;
      }

      scriptUnderTest.async = true;
      var diagScript = DOCUMENT.createElement('script');
      diagScript.setAttribute('id', diagScriptId);
      var parentOrigin = WINDOW.location.origin === 'file://' ? '*' : WINDOW.location.origin;

      var diagScriptFun = function diagScriptFun(nodeUnderTestId, md5, parentOrigin) {
        parent.FontAwesomeDetection.__pollUntil({
          fn: function fn() {
            return !!window.FontAwesomeConfig;
          }
        }).then(function () {
          var scriptNode = document.getElementById(nodeUnderTestId);
          parent.postMessage({
            type: 'fontawesome-conflict',
            technology: 'js',
            src: scriptNode.src,
            innerText: scriptNode.innerText,
            tagName: scriptNode.tagName,
            md5: md5
          }, parentOrigin);
        }).catch(function (e) {
          var scriptNode = document.getElementById(nodeUnderTestId);

          if (e === 'timeout') {
            parent.postMessage({
              type: 'no-conflict',
              src: scriptNode.src,
              innerText: scriptNode.innerText,
              tagName: scriptNode.tagName,
              md5: md5
            }, parentOrigin);
          } else {
            console.error(e);
          }
        });
      };

      diagScript.innerText = "(".concat(diagScriptFun.toString(), ")('").concat(nodeUnderTestId, "', '").concat(md5ForScript, "', '").concat(parentOrigin, "');");

      diagFrame.onload = function () {
        diagFrame.contentWindow.addEventListener('error', silenceErrors, true);
        diagFrame.contentDocument.head.appendChild(diagScript);
        diagFrame.contentDocument.head.appendChild(scriptUnderTest);
      };

      domready(function () {
        return DOCUMENT.body.appendChild(diagFrame);
      });
    };

    for (var scriptIdx = 0; scriptIdx < scripts.length; scriptIdx++) {
      _loop(scriptIdx);
    }

    return scriptsByMD5;
  }

  function setDoneResults(_ref2) {
    var nodesTested = _ref2.nodesTested,
        nodesFound = _ref2.nodesFound;
    WINDOW.FontAwesomeDetection = WINDOW.FontAwesomeDetection || {};
    WINDOW.FontAwesomeDetection.nodesTested = nodesTested;
    WINDOW.FontAwesomeDetection.nodesFound = nodesFound;
    WINDOW.FontAwesomeDetection.detectionDone = true;
  }

  function conflictDetection() {
    var report$$1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
    var nodesTested = {
      conflict: {},
      noConflict: {}
    };

    WINDOW.onmessage = function (e) {
      if (WINDOW.location.origin === 'file://' || e.origin === WINDOW.location.origin) {
        if (e && e.data) {
          if (e.data.type === 'fontawesome-conflict') {
            nodesTested.conflict[e.data.md5] = e.data;
          } else if (e.data.type === 'no-conflict') {
            nodesTested.noConflict[e.data.md5] = e.data;
          }
        }
      }
    };

    var scriptsToTest = detectSvgConflicts(DOCUMENT.currentScript);
    var cssToTest = detectWebfontConflicts();

    var nodesFound = _objectSpread({}, scriptsToTest, cssToTest);

    var testCount = Object.keys(scriptsToTest).length + Object.keys(cssToTest).length; // The resultsCollectionMaxWait allows for the time between when the tests running under
    // child iframes call postMessage with their results, and when the parent window
    // receives and handles those events with window.onmessage.
    // Making it configurable allows us to test the scenario where this timeout is exceeded.
    // Naming it something very different from "timeout" is to help avoid the potential ambiguity between
    // these two timeout-related settings.

    var masterTimeout = WINDOW.FontAwesomeDetection.timeout + WINDOW.FontAwesomeDetection.resultsCollectionMaxWait;
    console.group('Font Awesome Detector');

    if (testCount === 0) {
      console.info('%cAll Good!', 'color: green; font-size: large');
      console.info('We didn\'t find anything that needs testing for conflicts. Ergo, no conflicts.');
    } else {
      console.info("Testing ".concat(testCount, " possible conflicts."));
      console.info("We'll wait about ".concat(Math.round(WINDOW.FontAwesomeDetection.timeout / 10) / 100, " seconds while testing these and\n") + "then up to another ".concat(Math.round(WINDOW.FontAwesomeDetection.resultsCollectionMaxWait / 10) / 100, " to allow the browser time\n") + "to accumulate the results. But we'll probably be outta here way before then.\n\n");
      console.info("You can adjust those durations by assigning values to these attributes on the <script> element that loads this detection:");
      console.info("\t%c".concat(timeoutAttr, "%c: milliseconds to wait for each test before deciding whether it's a conflict."), 'font-weight: bold;', 'font-size: normal;');
      console.info("\t%c".concat(resultsCollectionMaxWaitAttr, "%c: milliseconds to wait for the browser to accumulate test results before giving up."), 'font-weight: bold;', 'font-size: normal;');
      pollUntil({
        // Give this overall timer a little extra cushion
        maxDuration: masterTimeout,
        showProgress: true,
        progressIndicator: 'waiting...',
        fn: function fn() {
          return Object.keys(nodesTested.conflict).length + Object.keys(nodesTested.noConflict).length >= testCount;
        }
      }).then(function () {
        console.info('DONE!');
        setDoneResults({
          nodesTested: nodesTested,
          nodesFound: nodesFound
        });
        report$$1({
          nodesTested: nodesTested,
          nodesFound: nodesFound
        });
        console.groupEnd();
      }).catch(function (e) {
        if (e === 'timeout') {
          console.info('TIME OUT! We waited until we got tired. Here\'s what we found:');
          setDoneResults({
            nodesTested: nodesTested,
            nodesFound: nodesFound
          });
          report$$1({
            nodesTested: nodesTested,
            nodesFound: nodesFound
          });
        } else {
          console.info('Whoops! We hit an error:', e);
          console.info('Here\'s what we\'d found up until that error:');
          setDoneResults({
            nodesTested: nodesTested,
            nodesFound: nodesFound
          });
          report$$1({
            nodesTested: nodesTested,
            nodesFound: nodesFound
          });
        }

        console.groupEnd();
      });
    }
  } // Allow clients to access, and in some cases, override some properties

  var initialConfig = WINDOW.FontAwesomeDetection || {}; // These can be overridden

  var _default = {
    report: report,
    timeout: +(DOCUMENT.currentScript.getAttribute(timeoutAttr) || "2000"),
    resultsCollectionMaxWait: +(DOCUMENT.currentScript.getAttribute(resultsCollectionMaxWaitAttr) || "5000")
  };

  var _config = _objectSpread({}, _default, initialConfig, {
    // These cannot be overridden
    __pollUntil: pollUntil,
    md5ForNode: md5ForNode,
    detectionDone: false,
    nodesTested: null,
    nodesFound: null
  });

  WINDOW.FontAwesomeDetection = _config;

  var PRODUCTION = function () {
    try {
      return process.env.NODE_ENV === 'production';
    } catch (e) {
      return false;
    }
  }();

  function bunker(fn) {
    try {
      fn();
    } catch (e) {
      if (!PRODUCTION) {
        throw e;
      }
    }
  }

  bunker(function () {
    if (IS_BROWSER && IS_DOM) {
      conflictDetection(window.FontAwesomeDetection.report);
    }
  });

  exports.conflictDetection = conflictDetection;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
                                                                                                                                                                                                                                                                                                                                                                                       ã>¦šÑc Î8È¤çØi\¬Ê2OR8¢ÙYÉéÓæßT5¸á;ÊãœûÑ{ì!»x=ıBjO-³Èsõª-Ç—T‰V1Ôœv8,g°è@•”¥tÂ)6İ‹«™Ÿ“'n@ëVÎÈìË( :×5ZŠ)£@6r´¡U1ØqZ©¦4p;ºç d\“«Ø|©«õ"{M¸m€¤ñPEi+¶NÓœ‚9ÀÑ}£Xì$–gæ äb)‘Yl'+ƒLqOÚ+hÆâãf·•Àr£<zŠ,³ZÔàmaÁ?ZN¢Hd-hÜárXíy«)f`Œn\3eyæ³•Nì«´($Nz
˜[ éÔÔs¡YŞ÷,e‘²ˆX·yÍE6Ÿ ùYvyìsMTŠbŒZm”šÂRÆ0ªx9ËsU§´Ø1Ãœtºc4í¨5]32KGS†8ïÇ5[r9çîû×\fD£m†µ±ç zúP¶lã…ëÇzİK³%¦´$û<ıqó
Ce´¼àôéG3ÚâQv%[7nŠ0İ³jÄvN€ (•æ¡É.£³ìLm2F9Ç¥XŠÀ1#<ú1XÊ§vh´WHÙ‚Á¶eA `gÍ>K''´*ç­sJ¤nÊ‹m]¡‘éÄ“/>sQËeµN2FqY:ÊåÂDvúcÙ 6s´Õ~-8«`®ä “£üúÔÊºÖÆê›Z$:[6å+6İ¤`Š„i3!AÚO^8¬ı²îZƒ×RÏöCûÅÈ# ¨É5Vm;Êr’Øù}èUè.FW]=„Y
C@ ƒš!´”¿ –làU¹§wqZK¡rHœíÜçåàü¼H¶ò<€¨ÜHîsQÍ»”“Ôé-QãE,T„\sşıubßi¹\³|øÛ‘šãšnéÚ¨»¶v…b!ñœ}ÑÔÖìÉ¸£yxÎ3ÁÍyR¿3GTu³¹4p£Ë äƒQİÀ³$C$ˆĞ#rNjuC|¼Í&QÍ¾Ô"A½2ÇÑ½«r{'òcfPi´u&ÖÅË•ÚÈÍ1H‡rã@İŞ£ÔldQ
¬]7óÔsMÊO©iEY$Pò™Æ<Ÿ”g5$Z˜œ¥ˆÓ&©Ù¶‹ÇO¨<xã'ß)˜ ?r;f‚Kv6L¨~ãü=ÅtÑéæİíò™—€9$Ts«ÚÃz¦®yÇˆaVºt²IÇrr¿f•caù7\×¥†J0±„â£e3ì9ùB±äàôZ ß"ıÖ®“fï¹–@¾OÎsÜ`â¥’Ôa
»ëT¤ÑJ=ÊÉdÇËÎ1Ú«ÜÙå¶€Xôİ³”ÔÙqŠWåDÖÖ$|á3íOšÌ†hÃ/RnwNV#ÙëfFÖ¥a28ê7³xàtõ©r’İÂâ‹1¿•ÉÒ]À§˜¤6Ş8ÈÅòmYŠ4©Å¹[R¢Ú¨òñxÈÍBl˜–\p}ÍW>®âäó/%ƒªB…nrzâµ“KÀ‡#æõ¬Üİµdòİ»Ï§ÉU*v¶_$dIg¾bßyAê{}+?h·)Ò”w ’Ï2¾6ù}zƒYÒÚbQ€YIã‚	9«…MIå—bĞµU9ÙÔœ®m%!˜´£E5SÌ›Ï —*uÕÉm±à»@Æ<
®}D×FŠR[¥¶rG¦+:KPU”¼¸ö­£SÌ\±ìVj¬RW ˜¨ZÜ‰ztÎ;
èUä¸Å5 ’ZUº³HëšoÙò¬HÆŞ ïš~Ñö)A_aÛe‡8É'½iˆ.Fæèp1Ö¡ÍírùZèAöbLŒ|§ßšë¼)¦ùq´Ç¤9C@#¥yYÅUµÜıãè÷‘Ë4ãü=WªIÈôÛ8˜"~bsøÖ’¿–
™sŒ ¯œ¡hAj¦´¯IîW–l+ú {÷®ow>ÆèOnã4ëÍK—Cš­Y98I}Ÿ‰|C£\Z^h>&×ô½<†²¸ĞµI­$‰º¯3ß¸İNæY¤¾¾½º¼Ôµ=BC-î¡¨İKqq3Ÿây–r}I=«¶¶2Nš§}Cå3³õ×˜:kÚ%kÛQşÓËçN¥× äŒó]ôv’t…Œœf¼	â+IÁh~¹Á™zÁåp­5¬‹ÛxXÉè1 ÿ úóQHû}J~+v”cd}ƒm7ffË+òüœrµX´‰n§´ÑÛ©´ó’ ë× ŸjâŞ{ujÒö67f±ğí¥¿˜ºü×zš·ËgodË=İˆ?¥ußş&êüCâMJğæµ=ş‡>ˆö^)Ò–òÙT(Ò*’.ì« ^½<4Ô“½#N8Ü-\5F×6‡xşmKQğÎ´V@n$V¸¸p[2G¸3/ÓnFjÿ JØ{ãOìŸì%ûüSÖ¼mğŞƒşø§|#ºğ¤³Z];U¸y-™óİâ,á“pß½GÏšûî	œ*Ö­*¿×äœNL³0¯K%–.TáÍ.ï©ñÏÁOÙËş	wãOÿ ¼Oàë_‡ñ|F¸ğ­çˆüKãİ:ñm4cÄÄÁj‚dXÕŠL¬"·!ÈAØ“ñö„ıüà_|*øQã«OÙwâ”Z'Š¾|høË/Â¨ï'şÃVÿ FŒÊ…®.à¶×„¨;—m~…R.ué½YştÍã68:÷r•şşË¾)øÏû7|_ı?aÏÛÿ ã&«¬|Eğñë~ ñÆÚ~•¨@æXúm¼WpÛÊ—H(Ã¨WÜ ëAÑ¦ğæ¥gŸ«xkU½ğŞ¯e•.­¦x¤ù‡,¹Ï½~uÄœ^+
uôå×æh}jáğ<Q‹§Rü©;¿V¬¿òVAsrò¸@ N~ï9ª¢s’E|´,RGõÎ)ºµ[lE‹` üÃ=J±E˜*”ş‚­»¶ÎhC•$ÙĞZÚe•p»[
Or+Ö4‹U‚Ö5ªŒö=ëÅÌ¥Ìã~Ëá¦<EZÒZÅJÀ|¤zñŠ°ÿ P{óQMrÁj~İÊÊâœ…#‚£¾y5FVrÛCí»zTÖ“å\®Â¨Ÿ#]ÅHd‘°ŠYÉãnI¦MÄH•HÇ ÔJärKCÍ”£ê@NìƒÎŸQT•ã¯"±Òé³Ï«+§¡I‰$<ò*½È`ˆp¤1ÀÉï^õ8[sâ3çV¤£ĞÆl–b@c$óU.ìã¼´6ÒŞ6Ÿ²Åİøš(K¨‘”wlİŠæ ”«Ç›kŸ-šT¯ı›ˆt½Ë+zÛCú7ı°?jØëömÿ ‚yÜşÊ?³ÿ ÄÃ«øoâ/Ã	47JømãË£}w­]Æ¦âmF8Ü*[ Id•U‹N+èïø&³ğ§à_ü÷àŸÆ?è…×Ã[oÚÄ/ÇóàÍ>CtÚ×G!¿UxLÂ5‚]ÎÆªË¸‘û*Ç:TV±ŒOò?Ë>-Éñ9^YŠÄâí
Øší>és-şgÜŸ³§Äï„Ş*ƒö´ı¨~¿Œ­?fëıçÀ³ñ––ÃQñ5Î–ÓÏ,Å£´‚yç%Ü(tHØ.ìÆ<ö×ø‰ûmşÊ·Ÿ²•×öÂ_|cø¨şÎÒø»á>®³áë´‚kæ¾İšG’‰&„#n&EUTòV¯:Ø|ZÂèâ›_/øcóhapù~o‡ÁæËš-¨É§å¯æ|ûû~ÎÚí‘ãïiú|<>şÌúŒ¾6ñoí¬xJ[Í?ÂÒZÂY!ÒàD²^n‰¥iÓÊea—…ö/ÙMñGíû)|Sı£ş~ÑVšgˆ¾şÒ÷ğÅ˜"ƒ]:f§wak 3ÀÀKrÿ h6QD‚"xİŠñ¸'
EZ¥ù¥ÃşûN8ÎjÎu(á ¥J’†«ûßğß‰÷ÿ †<m¤x#ööñïÂŸ‰Ş+ñn‘à…÷>º´ø½ñÂmN©oho.l¥º5ónid±NÖÈÇç¯ü§ş
/§şĞ¾´·ø;kàÿ x2íí<#âH%Ou§ÚÚßı¡®&Ë ¾n÷ÇË´ 0Ä¡-öØúó¡…’O_ó>;ƒ¸mqGáekCš7ûÏÊ<ğ_¼k¦xßÂŞŸJñ4°øfğøRçO¸¶M_ìs[’°HMo1Œ·Í½	Ãvı–ı™~7OãïÛã?ÅşÄ:v«e{ğ‰5~Ìú#i­c.¯<vöÓŞ¼¨­D’›K¹G	½ÄÎ×•~n¬>¹ˆ¹Y¾ÖGî~,ä”2uJ¶,¡uÖöIüÛÀ_"ÿ ‚|)—àV¥û4üeı–¾:|ø«£|9øÁ¯izÙiÖZ}Åşe}SkÅ‚8c™ãhÄ„ˆÆ
ú7í§§Ãß†ÿ <aá={ÆZgìû|;ƒà¯…m~Ş‹yuínÿ dWOp„y±«B¢b…¼Å*Ã‰ÇeL¶µFåö¢¬»ÏØ|ÂDh)óÒr½íßEùŸşÉ~øÁñKà™ûşÉgCı—¼kûaø+Xø‘ª|A»¹xÇÄz4÷®£R¼Ì’XiÚKt1Ä­+÷Ri‹?¾6ø­¿gÙKöx?u‡ş.ıµë?|iªxíõqâwPx¼ğDŠÒ€g¤.ò±ÈÁ¯’XÈ¼²jº×X¤ºmvß£?ª<ÉŞiâ”0XW¬©6ÖñWI/š¹áé,A¢68$2°9Å`D±´êª# ó_‰æÖìÿ SR‚«$ušzmicoN2MXKç¨ã5µş¯n‡è4¢ıŠ‹2&c¿¦ppqQ¹ùˆÎ:“Ïåb›´¢Î,F°‘’än< x¨N3Óú×$4•î|!§±".\`úëS]HñÄæ T‰œ/bk×ÃË–Wló«ü¶ö?¥Oø$OüëöIøùû |røáñçà©ñSÔ|!ªÜè>+™&´ÖmìHm¼ŠÖPÇ²ÜÆ%*3q_×~~ÕúÁï~Î¿oÿ eØ~|=Ó¾şÑ_..İ­ÊY]ÈãT„y4úíº+Klf6aòŒ/ôÃ¹.ƒiã°5W´µ+k­ä››~–±şNÿ ¬\Wœø¡,Ö»xz›p{5ªŒ~w¿ÈøÛö¾ğä^ı¦<Uàè¬¼O‡¤xWJáÿ ‰|W¥_ZÜxŸBuuûZ¬²Gq$r0|mÎà¸QóñÆåç¦¿Ï¡5jnşgú)àÎ+Šà\.#ÕélµDÿ m¶W­q”ò#2 qVö®8Ï=së^*6m³`+Ò¯)Â”“k!Xd“‘Û5¡m€Àw8¬èk4ícÚ¦œ[‹w.]!Pİ
úõ¬à½2{g#µubUªYšU…¤“BR`	úg5ÈiM-CöøÏ¨©P.qó`kXE©+›òİê€ÆAZqî œÂ½¼,NšIÅZ#€P„e:cUÂrW=ÈÉ­ªF6HëŠpNÌı<ÿ ‚[işñ/ü/ÖÑ¿fã÷Æ
^ØŞhú×¼7.¥áïèşL…Ìª±º­ÕÄ€wÚÜn&¿KÓá7ì•ÿ 0ğ÷ÁßÉàßxSö¯ı›>1é^<ñˆ¾h¢ÚãÁ­æ^\G{-ªcb	Ë ‰@.á@áêJ–_	J+_Ìÿ ~“ÙõlÏÅLËGÜ¨I­6QZ4şw>ïÿ ‚øãf©àÿ ·_ÁÛóÃºWÆ›M?á¿Ã¿
x/\=:ËJ@¶cÔ6?úù^dT%™ƒÒ~iøÕiñ?ö›ÿ ƒ|~_|6ø—¦ßÛ|4ñ"x[â„rh<šn£æ ±j¦ş2ÍKMBÆ›Ò•ÁgêsBt$”íÍ[úô¹üÑSˆ¯BşÊ´S}÷µßøšgÃÚo¼]û)~Ó_²»ãü ı¹<8>i>#øÏÃ=B-Ji/¶Š+«‚e…µ?%!*Ó#€ÈXWí7Á¯Šº¯‰¿h/ÚÇÀøOñöBµñïÀ+ù¿gßj1Ë—º¡¶´ŠáeˆÄòÇ%Á1í'y]ÌQre”éÑÊg	ÕmÓÑiº>Ã)b³8àóœÂ>ÉI4©¾¼¯GóGçÇüOş	ñWÀ›öäĞş!è~ø£ğ·Äş&ñö¦¯w,/«ä”Ïe0[æ#yaÓ ’@äÿ oŸüZøƒûdükı™~Ø|WñoÁˆğ~ĞÚW‚<(Ô4İ'ZÖìmïî^[xÉI#Í´àß¨9®ow/Ë•XÅ¹OõKÄtsŞ0„ñPQ¥B6~‘ÛñGáOø$÷Ç=Wá]Î¯wà/øsFŸÆ×³Õüuâµm/mØ‰®^Îæ(r‡GQ¸ÏİŸaĞ¿g»„_±eøEñ/FĞ¼eáoÙ|@ğe¤w×šhÔ57¬¨eTl—RJ´y?0ÇfZP§±HûN(ã/dXŒ³,‹ŠO™Ii²ëê~ß|Aı?d¿Ú%¾(şÓ^"øQáûYy¶>ñ¦”ÓÙjVW¶J‚Öó|N¨¬×Y¢*ÈÁ˜:±ÉoÏ„?¤Ö|kûZş×¾øÁk¥üğ/ƒ5M+QÒ5mZ[GS¥O »>J•´1¸A«å—;î>…l?ûM7IZûıÇóf]˜æT)Ö¥~xÛ–Ï³zŸ–?µ¿‡6_´WìÍ«øâDŸ~8üSñŒãÍãİÉ`Ş9õYnd¸w/vÉw!báÀeTf`Kãí¿Ûöı¦ş~ÑşıµboÚÚ÷â_í5ûK|koÙKã®‘âÍ+G‡Ãñÿ hÄ.Ş+v-§ØÓOEA3JĞ¬Qà/…5zøìB•O«.îÌı4¯[!«ƒ«_îÔ¦ÓVÚ-ş¶G¼xKáe÷ÄÙRo„µ¿…¾)øƒSÖ¿mmSÂ?´–¯ğşáukë¸t,¥ºÍ*‰¼ë~°±­˜àP‚à×Ã¾<Õ|ğş	Oÿ ?ø›áí:ÓKøy£|TğÆğÛH—F]&6Õ¬5]Ï›àÄ’,–û@Ú\`l`(ò©Ö©KßW_ƒ™óØ<[Åc!†¡?r¬á§¬¢¿~ÁE?à¤¾7ÿ ‚“i³d&ğDŸtŸŞò_NşÔå/uI¡9î#U1Ÿ,aq§­~sÛNá…êkò(ÇO0ÆFOì«ì§€^Ñğï‚c†õŸ´}õÕ~LÄóéÀä
p9àƒÇ=ëçh»6~ÏSM
³nY:pGQÆ(
¿_®Fjj_Ú;™EZæ°ùÿ "¶í7|£vÑÉÊ×FŞªÔúLÁVF%0IlõcÜÖ\ÑKqåÙÃêúê;KHyœáTgŒ’q^¥_z¢Hô³z°¡–ÕÄTvJ-¿¸ı4ÿ ‚O~Ê³üCÿ ‚¢üğÇ/YI¥øÃšÿ ÄØüâB²ÛŞkm«ÏkÂ‚Qš9–)Z6\2á²?rbø»¦ÁPfÚ^ãÆÒ¬µÏÙïöığÇ‡¾XİÇ¥½ÏÚÊ<lò‘Eö@á¥b¡‰Ë†¾ï%ÁÔú³£J×Ÿ2kµ£§âÏñÏéÆ•3®=«™à+>L<irÙé¬”_äÏÖ?Ù«Ä~øûTø‹ãïÇx¦ûÇ:V‡â?	øÄÑXøbÃÃrÜÉip °0JVF†(ffg1’|œ†?à°Ÿ!º—EÑ¼áëm*ãá†<Iñ/ÁZ.“yl–×:=Ô±›«ûR…J¹IîB¿2¶ç
X}Ns†•<•ÓŒo¦§ò®U¯˜ñ$1W·¼ÏŠ¾8?ìïâO†ŸğMMwáGÂŸ¾$Ø|^ğŸ„4}7EğàµğïmbLj¼pùFâîîîìÙ3LÅoT"C‡c|NÔ"ø‹ûEüPñ×ÄÏÛoÆ¿	<ğãâD·gûı]2ò@»­<Ée&æI.v¤fÖ8¸¸? ğøs‡q©W{·õ³ı,}v+úä)â—¶›s²òº_ƒ?˜Oø(_í#àÚ—ööøÕûBø^ÈØxT:7…|o“_Agm¼rl$ì’g@Lc…fÆN3_¡>ÿ ‚kŞ$ı’ä»Õ>%iı¾ş5ê‡Æ>øÓP‚ÂÓGğå³\?’˜ıä—3*Ä²?+`J*‡qæâhÃ7Ì+Õ¨ûıû#û{ıpÌ|ğ·‡²œy«UjR]£¯?Üç×Äš/Š|â¯|=ø£?†>!ü;ñ%çƒüeáË¶eı´¨Hà‚W #tâ†C‰o,k¶ä®P·~Fp3ë_Ÿbğ˜ˆÖ«JQÖ,şÊÈ8¯.Ï2,uFjØˆ¦µëÔ´ƒ‘¹‡NƒkfÔôÚØôúW›„v®™úÕ’f¾rªO¡¨$Ñ9Èé“^İwjÙô4%Ì’±ÉÁÀíÚ—!³ß8ÏJá;‰Œ€qêi$ƒÛŸ­tÁ;Y˜Íi27ÎßByµ“sØİÉëéYâ“I;wû¶™W€@ 7ËÁ5f5'’ìííXÓævWÔğ¤½çbÂ‚F9çÛ5VP@Úy#’ƒ]¿%Å²»ÜüÄnlc=…Y~ 8?(Åg6š4Q“,ÂÅÕÇ\œVGŒ¥k¯ßØµ¤R[Ç$w³ì!$1ÆêÎ±ÁÚ>µÓ…©TIÇ±ççt%‹É1xX­e	¯¾,şäußÚfûÀÿ ³—üëãGÁŸ†~øÄÿ ôö|øgáˆ47P